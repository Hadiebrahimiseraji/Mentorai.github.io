import express from "express";
import cors from "cors";
import sqlite3 from "sqlite3";
import { open } from "sqlite";
import bcrypt from "bcrypt";
import jwt from "jsonwebtoken";

const PORT = 8080;
const JWT_SECRET = "CHANGE_ME_TO_A_LONG_RANDOM_SECRET";
const app = express();

app.use(cors());
app.use(express.json({ limit: "2mb" }));

const db = await open({ filename: "./radmentor.sqlite", driver: sqlite3.Database });

await db.exec(`
CREATE TABLE IF NOT EXISTS users (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  username TEXT UNIQUE NOT NULL,
  password_hash TEXT NOT NULL,
  role TEXT NOT NULL DEFAULT 'STUDENT',
  grp TEXT NOT NULL DEFAULT 'CONTROL',
  created_at INTEGER NOT NULL
);

CREATE TABLE IF NOT EXISTS attempts (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER NOT NULL,
  username TEXT NOT NULL,
  role TEXT NOT NULL,
  grp TEXT NOT NULL,
  phase TEXT NOT NULL,
  ui_mode TEXT NOT NULL,
  case_id TEXT NOT NULL,
  started_at_ms INTEGER,
  duration_sec INTEGER,
  primary_dx TEXT,
  confidence TEXT,
  airway TEXT,
  findings TEXT,
  notes_free TEXT,
  quality_rotation INTEGER,
  quality_inspiration INTEGER,
  quality_penetration INTEGER,
  quality_note TEXT,
  rf_tension_ptx INTEGER,
  rf_massive_effusion INTEGER,
  ai_allowed INTEGER,
  ai_shown INTEGER,
  truth_primary_dx TEXT,
  truth_findings TEXT,
  score INTEGER,
  correct_dx INTEGER,
  created_at INTEGER NOT NULL,
  FOREIGN KEY(user_id) REFERENCES users(id)
);
`);

async function ensureAdmin() {
  const existing = await db.get("SELECT id FROM users WHERE role='ADMIN' LIMIT 1");
  if (existing) return;
  const hash = await bcrypt.hash("admin1234", 12);
  await db.run(
    "INSERT INTO users (username,password_hash,role,grp,created_at) VALUES (?,?,?,?,?)",
    ["admin", hash, "ADMIN", "CONTROL", Date.now()]
  );
  console.log("Admin created: username=admin password=admin1234 (PLEASE CHANGE)");
}
await ensureAdmin();

function signToken(user) {
  return jwt.sign(
    { id: user.id, username: user.username, role: user.role, group: user.grp },
    JWT_SECRET,
    { expiresIn: "12h" }
  );
}

function auth(req, res, next) {
  const h = req.headers.authorization || "";
  const token = h.startsWith("Bearer ") ? h.slice(7) : "";
  try {
    const payload = jwt.verify(token, JWT_SECRET);
    req.user = payload;
    next();
  } catch {
    res.status(401).json({ error: "Unauthorized" });
  }
}

function adminOnly(req, res, next) {
  if (req.user?.role !== "ADMIN") return res.status(403).json({ error: "Forbidden" });
  next();
}

// AUTH
app.post("/auth/login", async (req, res) => {
  const { username, password } = req.body || {};
  if (!username || !password) return res.status(400).json({ error: "Missing credentials" });

  const user = await db.get("SELECT * FROM users WHERE username=?", [username]);
  if (!user) return res.status(401).json({ error: "Invalid username/password" });

  const ok = await bcrypt.compare(password, user.password_hash);
  if (!ok) return res.status(401).json({ error: "Invalid username/password" });

  const token = signToken(user);
  res.json({
    token,
    user: { id: user.id, username: user.username, role: user.role, group: user.grp }
  });
});

// SUBMIT ATTEMPT
app.post("/attempts", auth, async (req, res) => {
  const u = req.user;
  const a = req.body || {};

  // حداقل‌های پژوهشی
  if (!a.caseId || !a.phase || !a.uiMode) return res.status(400).json({ error: "Bad attempt payload" });

  const now = Date.now();
  const truthPrimaryDx = a.truth?.primaryDx || "";
  const truthFindings = Array.isArray(a.truth?.findings) ? a.truth.findings.join(",") : "";
  const findings = Array.isArray(a.findings) ? a.findings.join(",") : "";

  await db.run(`
    INSERT INTO attempts (
      user_id, username, role, grp,
      phase, ui_mode, case_id, started_at_ms, duration_sec,
      primary_dx, confidence, airway, findings, notes_free,
      quality_rotation, quality_inspiration, quality_penetration, quality_note,
      rf_tension_ptx, rf_massive_effusion,
      ai_allowed, ai_shown,
      truth_primary_dx, truth_findings,
      score, correct_dx,
      created_at
    ) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
  `, [
    u.id, u.username, u.role, u.group,
    a.phase, a.uiMode, a.caseId, a.startedAtMs || null, a.durationSec ?? null,
    a.primaryDx || "", a.confidence || "", a.airway || "", findings, a.notes?.free || "",
    a.quality?.rotation ? 1 : 0, a.quality?.inspiration ? 1 : 0, a.quality?.penetration ? 1 : 0, a.quality?.note || "",
    a.redFlags?.tensionPtx ? 1 : 0, a.redFlags?.massiveEffusion ? 1 : 0,
    a.aiPolicy?.aiAllowed ? 1 : 0, a.aiPolicy?.aiShown ? 1 : 0,
    truthPrimaryDx, truthFindings,
    a.score ?? null, a.correctDx ? 1 : 0,
    now
  ]);

  res.json({ ok: true });
});

// ADMIN: create user
app.post("/admin/users", auth, adminOnly, async (req, res) => {
  const { username, password, group } = req.body || {};
  if (!username || !password) return res.status(400).json({ error: "Missing fields" });

  const grp = (group === "AI") ? "AI" : "CONTROL";
  const hash = await bcrypt.hash(password, 12);

  try {
    await db.run(
      "INSERT INTO users (username,password_hash,role,grp,created_at) VALUES (?,?,?,?,?)",
      [username, hash, "STUDENT", grp, Date.now()]
    );
    res.json({ ok: true });
  } catch (e) {
    res.status(400).json({ error: "Username already exists" });
  }
});

// ADMIN: list attempts
app.get("/admin/attempts", auth, adminOnly, async (req, res) => {
  const { user, phase } = req.query;
  const where = [];
  const params = [];

  if (user) { where.push("username LIKE ?"); params.push(`%${user}%`); }
  if (phase) { where.push("phase = ?"); params.push(phase); }

  const sql = `
    SELECT
      id, username, role, grp, phase, ui_mode, case_id,
      duration_sec, primary_dx, confidence, airway, findings,
      ai_allowed, ai_shown, truth_primary_dx, score, correct_dx, created_at
    FROM attempts
    ${where.length ? "WHERE " + where.join(" AND ") : ""}
    ORDER BY created_at DESC
    LIMIT 500
  `;

  const rows = await db.all(sql, params);
  res.json({
    items: rows.map(r => ({
      id: r.id,
      username: r.username,
      role: r.role,
      group: r.grp,
      phase: r.phase,
      uiMode: r.ui_mode,
      caseId: r.case_id,
      durationSec: r.duration_sec,
      primaryDx: r.primary_dx,
      confidence: r.confidence,
      airway: r.airway,
      findings: r.findings,
      aiAllowed: !!r.ai_allowed,
      aiShown: !!r.ai_shown,
      truthPrimaryDx: r.truth_primary_dx,
      score: r.score,
      correctDx: !!r.correct_dx,
      createdAt: r.created_at
    }))
  });
});

// ADMIN: export CSV
app.get("/admin/attempts/export", auth, adminOnly, async (req, res) => {
  const rows = await db.all(`SELECT * FROM attempts ORDER BY created_at DESC`);
  const headers = Object.keys(rows[0] || { empty: "" });
  const esc = (v) => `"${String(v ?? "").replaceAll('"','""')}"`;
  const lines = [
    headers.join(","),
    ...rows.map(r => headers.map(h => esc(r[h])).join(","))
  ];
  res.json({ csv: lines.join("\n") });
});

app.listen(PORT, () => console.log(`API running on http://localhost:${PORT}`));
